import { createHash, createCipheriv, createDecipheriv } from "crypto";
import { Cipher, Decipher, randomBytes } from "node:crypto";
import { Buffer } from "node:buffer";

export enum QCError {
  MALFORMED_INPUT = "MALFORMED_INPUT",
  INVALID_VERSION_HEADER = "INVALID_VERSION_HEADER",
  TRANSCODER_FAILURE = "TRANSCODER_FAILURE",
  MESSAGE_AUTHENTICATION_FAILURE = "MESSAGE_AUTHENTICATION_FAILURE",
}

type QCSplitArray = [
  version: string,
  encoding: string,
  padding: string,
  type: string,
  timestamp: string,
  ciphertext: string,
  trailer: string,
];

type TranscoderFactory = (
  algorithm: string,
  key: Buffer,
  iv: Buffer,
) => Cipher | Decipher;

/** No-brainer secure cryptography implementation for any kind of data */
export class QuickCryptError implements Error {
  name: string;
  message: string;
  cause?: unknown;

  constructor(id: QCError, message: string, cause?: unknown) {
    this.name = id as string;
    this.message = message;
    this.cause = cause;
  }
}

export class QuickCrypt {
  private static readonly VERSION_HEADER = "qc1";
  private static readonly ENCRYPTION_ALGORITHM = "aes-256-cbc";
  private static readonly DERIVATION_ALGORITHM = "sha256";
  private static readonly CIPHERTEXT_BLOCK_BYTE_SIZE = 16;
  private static readonly CIPHERTEXT_KEY_BYTE_SIZE = 32;
  private static readonly MAC_ALGORITHM = "sha256";
  private static readonly CIPHERTEXT_IV_BYTE_SIZE =
    this.CIPHERTEXT_KEY_BYTE_SIZE / 2;
  private static readonly PLAINTEXT_BLOCK_PADDING = 2;

  private static readonly FALLBACK_QC_KEY = "test123test";
  private static readonly FALLBACK_QC_SALT = "2137pope2137";
  private static readonly FALLBACK_QC_IV = "gorbert69nierczak";
  private static readonly FALLBACK_QC_MAC_SECRET = "uuh2137uuh";

  public static readonly SEPARATOR = ":";
  public static readonly TRAILER = "$";

  private static performOperation_SHA256_AES256CBC(
    instanceFactory: TranscoderFactory,
    data: Buffer,
    keyPhrase?: string,
  ): Buffer {
    try {
      const key = keyPhrase ?? process.env.QC_KEY ?? this.FALLBACK_QC_KEY;
      const salt = process.env.QC_SALT ?? this.FALLBACK_QC_SALT;
      const iv = process.env.QC_IV ?? this.FALLBACK_QC_IV;

      const derivedKey = createHash(this.DERIVATION_ALGORITHM)
        .update(key)
        .update(salt)
        .digest()
        .subarray(0, this.CIPHERTEXT_KEY_BYTE_SIZE);
      const derivedIv = createHash(this.DERIVATION_ALGORITHM)
        .update(iv)
        .update(salt)
        .digest()
        .subarray(0, this.CIPHERTEXT_IV_BYTE_SIZE);

      const transcoder = instanceFactory(
        this.ENCRYPTION_ALGORITHM,
        derivedKey,
        derivedIv,
      );
      return Buffer.concat([transcoder.update(data), transcoder.final()]);
    } catch (e) {
      throw new QuickCryptError(
        QCError.TRANSCODER_FAILURE,
        "Operation failed due to invalid data supplied to the transcoder (most likely wrong key, salt or IV).",
        e,
      );
    }
  }

  private static validateWrappedInput(wrapped: string): QCSplitArray {
    const splits = wrapped.split(this.SEPARATOR);
    if (splits.length !== 7 || splits[6] !== this.TRAILER)
      throw new QuickCryptError(
        QCError.MALFORMED_INPUT,
        "Operation failed due to malformed input structure (most likely you are passing data that was not generated by this library)",
      );
    if (splits[0] !== this.VERSION_HEADER) {
      throw new QuickCryptError(
        QCError.INVALID_VERSION_HEADER,
        "Operation failed due to invalid version header (most likely you are trying to parse message from different version of this library).",
      );
    }
    return splits as QCSplitArray;
  }
  static wrap<T>(
    data: T,
    keyPhrase?: string,
    outputEncoding: BufferEncoding = "hex",
  ): string {
    const unifiedData =
      data instanceof Buffer
        ? data
        : typeof data === "string"
          ? Buffer.from(data, "utf-8")
          : Buffer.from(JSON.stringify(data), "utf-8");

    // For proper security level we need to ensure that our input size is enough.
    // If it's under 2 blocks size we are going to apply padding to that size.
    // And also we will mix block of random trash bytes within the first two blocks to prevent plaintext attack.
    const paddingSize =
      unifiedData.length >=
      this.CIPHERTEXT_BLOCK_BYTE_SIZE * this.PLAINTEXT_BLOCK_PADDING
        ? 0
        : this.CIPHERTEXT_BLOCK_BYTE_SIZE * this.PLAINTEXT_BLOCK_PADDING -
          unifiedData.length;

    const paddedData =
      unifiedData.length >=
      this.CIPHERTEXT_BLOCK_BYTE_SIZE * this.PLAINTEXT_BLOCK_PADDING
        ? unifiedData
        : Buffer.concat([unifiedData, Buffer.alloc(paddingSize, 0)]);

    const bloatSource = randomBytes(this.CIPHERTEXT_BLOCK_BYTE_SIZE);

    const bloatedBlocks = Buffer.alloc(
      this.CIPHERTEXT_BLOCK_BYTE_SIZE * this.PLAINTEXT_BLOCK_PADDING,
    );

    for (let i = 0; i < this.CIPHERTEXT_BLOCK_BYTE_SIZE; i++) {
      bloatedBlocks[i * 2] = bloatSource[i];
      bloatedBlocks[i * 2 + 1] = paddedData[i];
    }

    const bloatedData = Buffer.concat([
      bloatedBlocks,
      paddedData.subarray(this.CIPHERTEXT_BLOCK_BYTE_SIZE),
    ]);

    // For validating authenticity and integrity of message.
    const macTimeStamp = new Date().getTime().toString();
    const mac = createHash(this.MAC_ALGORITHM)
      .update(bloatedData)
      .update(process.env.QC_MAC_SECRET ?? this.FALLBACK_QC_MAC_SECRET)
      .update(macTimeStamp)
      .digest();

    const ciphertextBuffer = this.performOperation_SHA256_AES256CBC(
      createCipheriv,
      Buffer.concat([
        bloatedData,
        mac.subarray(0, this.CIPHERTEXT_BLOCK_BYTE_SIZE),
      ]),
      keyPhrase,
    );

    const finalOutput = [
      this.VERSION_HEADER,
      outputEncoding,
      paddingSize,
      data instanceof Buffer ? "Buffer" : typeof data,
      macTimeStamp,
      ciphertextBuffer.toString(outputEncoding),
      this.TRAILER,
    ];

    return finalOutput.join(this.SEPARATOR);
  }

  static unwrap<T>(data: string, keyPhrase?: string): T {
    const splits = this.validateWrappedInput(data);

    const [, inputEncoding, padding, outputType, macTs, ciphertext] = splits;

    const bloatedPlaintextBufferWithMac =
      this.performOperation_SHA256_AES256CBC(
        createDecipheriv,
        Buffer.from(ciphertext, inputEncoding as BufferEncoding),
        keyPhrase,
      );

    const originalMacBlock = bloatedPlaintextBufferWithMac.subarray(
      bloatedPlaintextBufferWithMac.length - this.CIPHERTEXT_BLOCK_BYTE_SIZE,
    );

    const bloatedPlaintextBuffer = bloatedPlaintextBufferWithMac.subarray(
      0,
      bloatedPlaintextBufferWithMac.length - this.CIPHERTEXT_BLOCK_BYTE_SIZE,
    );

    // Verify authenticity and integrity.
    const mac = createHash(this.MAC_ALGORITHM)
      .update(bloatedPlaintextBuffer)
      .update(process.env.QC_MAC_SECRET ?? this.FALLBACK_QC_MAC_SECRET)
      .update(macTs)
      .digest()
      .subarray(0, this.CIPHERTEXT_BLOCK_BYTE_SIZE);

    if (mac.compare(originalMacBlock) !== 0) {
      throw new QuickCryptError(
        QCError.MESSAGE_AUTHENTICATION_FAILURE,
        "Failed to verify authenticity and integrity of input data (possibly tampered or misconfigured ENV variables).",
      );
    }

    // We need to remove garbage bytes applied in wrapping step.
    // (And if present remove padding.)
    const debloatedHeader = Buffer.alloc(this.CIPHERTEXT_BLOCK_BYTE_SIZE);
    for (let i = 0; i < this.CIPHERTEXT_BLOCK_BYTE_SIZE; i++) {
      debloatedHeader[i] = bloatedPlaintextBuffer[i * 2 + 1];
    }

    const paddedPlaintextBuffer = Buffer.concat([
      debloatedHeader,
      bloatedPlaintextBuffer.subarray(
        this.CIPHERTEXT_BLOCK_BYTE_SIZE * this.PLAINTEXT_BLOCK_PADDING,
      ),
    ]);

    const plaintextBuffer = paddedPlaintextBuffer.subarray(
      0,
      paddedPlaintextBuffer.length - parseInt(padding),
    );

    if (outputType === "Buffer") {
      return plaintextBuffer as T;
    }

    const plaintextString = plaintextBuffer.toString("utf-8");

    if (outputType !== "string") {
      return JSON.parse(plaintextString) as T;
    }

    return plaintextString as T;
  }

  static typeofWrapped(wrapped: string): string {
    const splits = this.validateWrappedInput(wrapped);

    const [, , , outputType] = splits;

    if (outputType === "Buffer") return "object";
    return outputType;
  }
}
